<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8 />
    <title>GeoJSON Test Data Generator</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no'/>
    <script src='https://api.tiles.mapbox.com/mapbox.js/v2.1.5/mapbox.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox.js/v2.1.5/mapbox.css' rel='stylesheet'/>
    <link href='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-draw/v0.2.2/leaflet.draw.css' rel='stylesheet' />
    <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-draw/v0.2.2/leaflet.draw.js'></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-geodesy/v0.1.0/leaflet-geodesy.js'></script>
</head>

<body>

<style>
    html, body {
    height: 100%;
    }

    body {
    font-family: RobotoDraft, 'Helvetica Neue', Helvetica, Arial;
    /*  color: #FFF;*/
    margin: 0;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    }

    #map {
    position:absolute;
    top:0;
    bottom:0;
    width:100%;
    z-index:0;
    }

    button {

        position:relative;
        left:10px;
        margin-top:210px;
        z-index: 2;
    }
</style>

    <div id='map'></div>

<script>
    
    // Map setup
    L.mapbox.accessToken = 'pk.eyJ1IjoiYmVuY28iLCJhIjoibFR5OENaSSJ9.1FJH6zh7FgXL1c0t_eg5NA';
    var map = L.mapbox.map('map','benco.lhgcp30a').setView([40.769, -97.00], 4);

    // Implement feature drawing
    var featureGroup = L.featureGroup().addTo(map);

    var drawControl = new L.Control.Draw({
      edit: {
        featureGroup: featureGroup
      },
      draw: {
        polygon:  {
            allowIntersection: false, // Restricts shapes to simple polygons
            drawError: {
                color: '#e1e100', // Color the shape will turn when intersects
                message: '<strong>Oh snap!<strong> you can\'t draw that!' // Message that will show when intersect
            },
            shapeOptions: {
                color: '#bada55'
            }
        },
        polyline: false,
        rectangle: false,
        circle: false,
        marker: true
      }
    }).addTo(map);

    map.on('draw:created', function(e) {
        showPolygonArea(e);

    });

    map.on('draw:edited', function(e) {
        showPolygonAreaEdited(e);
    });

    function showPolygonAreaEdited(e) {
      e.layers.eachLayer(function(layer) {
        showPolygonArea({ layer: layer });
      });
    }
    function showPolygonArea(e) {
      featureGroup.clearLayers();
      featureGroup.addLayer(e.layer);
      e.layer.bindPopup((LGeo.area(e.layer) / 1000000).toFixed(2) + ' km<sup>2</sup>');
      e.layer.openPopup();

      // Defines user polygon upon create/edit
      getUserPolygon(e);
    }

    // Get user input

        // Number of points desired (up to some maximum)
        var btn = document.createElement("BUTTON");
        var t = document.createTextNode("Generate");
        btn.appendChild(t);
        btn.onclick = function () {
            N = parseInt(prompt("How many markers would you like?"));
            title = prompt("Please give your set a title (optional)");
            alert("Please draw your marker boundries with a polygon");
        };
        document.body.appendChild(btn);

        // Defines polygon variable
        function getUserPolygon(e) {
            polygon = e.layer;
            console.log(polygon);
            outerBounds();
        };

    // Determine max boundries around polygon
        function outerBounds() {

            var coords = polygon._latlngs;
            var latList = [], lngList = [];

            for (var i = 0; i < coords.length; i++ ) {
                latList.push(coords[i]["lat"]);
                lngList.push(coords[i]["lng"]);
            };

            latList.sort(function(a,b) {return a-b});
            lngList.sort(function(a,b) {return a-b});

            minLat = latList.shift();
            maxLat = latList.pop();
            minLng = lngList.shift();
            maxLng = lngList.pop();

            console.log("maxLat: " + maxLat + ", minLat: " + minLat + 
                        ", maxLng: " + maxLng + ", minLng: " + minLng );

        }

    // Generate psuedo-random markers

        // Random x, random y

            // Pool

            // Pip: Does point lie within user's polygon?

                // If true, add to pool

                // else, continue

            // Break if pool length >= N



</script>

</body>

</html>

